bender_attack = {
    -- air
    ['air_ball'] = {
        min = 5,
        max = 7,
        min_mult = 0.5,
        max_mult = 0.7
    },
    ['air_wheel'] = {
        min = 5,
        max = 7,
        min_mult = 0.5,
        max_mult = 0.7
    },
    ['air_burst'] = {
        min = 8,
        max = 14,
        min_mult = 0.5,
        max_mult = 0.9
    },
    ['air_icywind'] = {
        min = 7,
        max = 12,
        min_mult = 0.5,
        max_mult = 0.9
    },
    ['air_bow1'] = {
        min = 5,
        max = 10,
        min_mult = 0.5,
        max_mult = 0.8
    },
    ['air_bow2'] = {
        min = 14,
        max = 18,
        min_mult = 0.6,
        max_mult = 0.9
    },
    ['air_bow3'] = {
        min = 16,
        max = 20,
        min_mult = 0.8,
        max_mult = 1.0
    },
    ['air_gust'] = {
        min = 10,
        max = 13,
        min_mult = 0.6,
        max_mult = 0.9
    },
    ['air_fan'] = {
        min = 11,
        max = 13,
        min_mult = 0.6,
        max_mult = 0.9
    },
    ['air_tornado'] = {
        min = 16,
        max = 19,
        min_mult = 0.8,
        max_mult = 1.0
    },
    ['air_wings'] = {
        min = 14,
        max = 16,
        min_mult = 0.6,
        max_mult = 0.9
    },
    ['air_twinkle'] = {
        min = 14,
        max = 16,
        min_mult = 0.4,
        max_mult = 0.7
    },
    ['air_hurricane'] = {
        min = 15,
        max = 17,
        min_mult = 0.8,
        max_mult = 1.2
    },
    ['air_doom'] = {
        min = 10,
        max = 13,
        min_mult = 0.6,
        max_mult = 0.9
    },

    -- earth
    ['earth_crush'] = {
        min = 8,
        max = 10,
        min_mult = 0.8,
        max_mult = 1.3
    },
    ['earth_rock1'] = {
        min = 4,
        max = 6,
        min_mult = 0.3,
        max_mult = 0.8
    },
    ['earth_rock2'] = {
        min = 6,
        max = 8,
        min_mult = 0.4,
        max_mult = 0.9
    },
    ['earth_rock3'] = {
        min = 8,
        max = 10,
        min_mult = 0.5,
        max_mult = 1.1
    },
    ['earth_punch'] = {
        min = 10,
        max = 15,
        min_mult = 0.7,
        max_mult = 1.2
    },
    ['earth_kick'] = {
        min = 5,
        max = 9,
        min_mult = 0.7,
        max_mult = 0.9
    },
    ['earth_wall'] = {
        min = 16,
        max = 20,
        min_mult = 1.9,
        max_mult = 2.5
    },
    ['earth_spikes'] = {
        min = 9,
        max = 12,
        min_mult = 1.8,
        max_mult = 2.5
    },
    ['earth_growth'] = {
        min = 5,
        max = 9,
        min_mult = 0.7,
        max_mult = 0.9
    },
    ['earth_petrify'] = {
        min = 5,
        max = 9,
        min_mult = 0.7,
        max_mult = 0.9
    },
    ['earth_barrier'] = {
        min = 2,
        max = 3,
        min_mult = 0.7,
        max_mult = 0.9
    },
    ['earth_quake'] = {
        min = 8,
        max = 10,
        min_mult = 1.4,
        max_mult = 1.6
    },
    ['earth_smash1'] = {
        min = 8,
        max = 12,
        min_mult = 0.4,
        max_mult = 0.8
    },
    ['earth_smash2'] = {
        min = 10,
        max = 12,
        min_mult = 0.8,
        max_mult = 1.2
    },
    ['earth_smash3'] = {
        min = 12,
        max = 14,
        min_mult = 0.9,
        max_mult = 1.5
    },

    -- water
    ['water_whip'] = {
        min = 8,
        max = 12,
        min_mult = 0.9,
        max_mult = 1.2
    },
    ['water_wave'] = {
        min = 10,
        max = 12,
        min_mult = 1.0,
        max_mult = 1.2
    },
    ['water_fang'] = {
        min = 10,
        max = 13,
        min_mult = 0.9,
        max_mult = 1.3
    },
    ['water_cannon'] = {
        min = 2,
        max = 4,
        min_mult = 0.9,
        max_mult = 1.0
    },
    ['water_clock'] = {
        min = 8,
        max = 10,
        min_mult = 0.9,
        max_mult = 1.3
    },
    ['water_spin'] = {
        min = 10,
        max = 15,
        min_mult = 1.0,
        max_mult = 1.5
    },
    ['water_icebeam'] = {
        min = 2,
        max = 4,
        min_mult = 0.9,
        max_mult = 1.3
    },
    ['water_bubble'] = {
        min = 8,
        max = 12,
        min_mult = 0.5,
        max_mult = 0.7
    },
    ['water_dragon'] = {
        min = 12,
        max = 16,
        min_mult = 1.0,
        max_mult = 1.4
    },
    ['water_storm'] = {
        min = 15,
        max = 18,
        min_mult = 0.9,
        max_mult = 1.3
    },
    ['water_tsunami'] = {
        min = 12,
        max = 16,
        min_mult = 1.5,
        max_mult = 1.9
    },
    ['water_fury'] = {
        min = 13,
        max = 15,
        min_mult = 0.9,
        max_mult = 1.3
    },

    -- fire
    ['fire_whip'] = {
        min = 10,
        max = 15,
        min_mult = 1.1,
        max_mult = 1.5
    },
    ['fire_blast'] = {
        min = 8,
        max = 10,
        min_mult = 1.1,
        max_mult = 1.3
    },
    ['fire_wave'] = {
        min = 14,
        max = 18,
        min_mult = 1.7,
        max_mult = 2.0
    },
    ['fire_spin'] = {
        min = 14,
        max = 16,
        min_mult = 1.5,
        max_mult = 2.5
    },
    ['fire_thrower'] = {
        min = 5,
        max = 9,
        min_mult = 1.5,
        max_mult = 1.7
    },
    ['fire_cannon'] = {
        min = 18,
        max = 20,
        min_mult = 1.5,
        max_mult = 1.7
    },
    ['fire_jolt'] = {
        min = 23,
        max = 26,
        min_mult = 1.5,
        max_mult = 1.7
    },
    ['fire_star'] = {
        min = 16,
        max = 19,
        min_mult = 1.5,
        max_mult = 1.7
    },
    ['fire_thunder'] = {
        min = 14,
        max = 16,
        min_mult = 1.8,
        max_mult = 2.1
    },
    ['fire_meteor'] = {
        min = 10,
        max = 14,
        min_mult = 1.8,
        max_mult = 1.9
    },
    ['fire_strike'] = {
        min = 14,
        max = 16,
        min_mult = 1.5,
        max_mult = 1.7
    },
    ['fire_charge'] = {
        min = 14,
        max = 16,
        min_mult = 1.5,
        max_mult = 1.7
    }
}

direc = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}, {-1, 1}, {1, 1}, {-1, -1}, {1, -1}}

function dirbetweenpos(pos1, pos2)
    local dpos = {
        x = pos2.x - pos1.x,
        y = pos2.y - pos1.y
    }
    if math.abs(dpos.x) == math.abs(dpos.y) then
        for a = 5, 8 do
            if dpos.x / math.abs(dpos.x) == direc[a][1] and dpos.y / math.abs(dpos.x) == direc[a][2] then
                return a - 1
            end
        end
    elseif math.abs(dpos.x) > math.abs(dpos.y) then
        if dpos.x > 0 then
            return 1
        else
            return 3
        end
    elseif math.abs(dpos.x) < math.abs(dpos.y) then
        if dpos.y > 0 then
            return 2
        else
            return 0
        end
    end
end

function getPushDir(cid, target)
    local cidpos = getThingPos(cid)
    local targetpos = getThingPos(target)
    if not isCreature(cid) or not isCreature(target) then
        return false
    end
    if cidpos.x == targetpos.x then
        if cidpos.y >= targetpos.y then
            return NORTH
        else
            return SOUTH
        end
    else
        if cidpos.x >= targetpos.x then
            if cidpos.y == targetpos.y then
                return WEST
            elseif cidpos.y >= targetpos.y then
                return NORTHWEST
            else
                return SOUTHWEST
            end
        else
            if cidpos.y == targetpos.y then
                return EAST
            elseif cidpos.y >= targetpos.y then
                return NORTHEAST
            else
                return SOUTHEAST
            end
        end
    end
end

function changepos(pos, deltax, deltay, deltaz)
    pos.x = pos.x + deltax
    pos.y = pos.y + deltay
    pos.z = pos.z + deltaz
    return pos
end

function getdeltabydirection(direction, sqms)
    local dir = direction + 1
    local tab = direc[dir]
    tab.x = tab[1] * sqms
    tab.y = tab[2] * sqms
    return tab
end

function changeposbydir(pos, direction, sqms)
    delta = getdeltabydirection(direction, sqms)
    return {
        x = pos.x + delta.x,
        y = pos.y + delta.y,
        z = pos.z
    }
end

function distBetween(cid1, cid2)
    return math.max(math.abs(getThingPos(cid1).x - getThingPos(cid2).x),
        math.abs(getThingPos(cid1).y - getThingPos(cid2).y))
end

function distBetween2(pos1, pos2)
    return math.max(math.abs(pos1.x - pos2.x), math.abs(pos1.y - pos2.y))
end

function rotateDelta90graus(delta)
    return {
        x = -delta.y,
        y = delta.x
    }
end

function getAreaWidthAndHeight(area)
    return #(area[1]), #area
end

function rotateAreaToRight(area)
    local width, height = getAreaWidthAndHeight(area)
    local newarea = {}
    local f = 0
    repeat
        table.insert(newarea, {})
        f = f + 1
    until f >= height
    for tx = 1, width do
        for ty = 1, height do
            local cx, cy = getAreaCenter(area)
            local delta = {
                x = tx - cx,
                y = ty - cy
            }
            local value = area[ty][tx]
            delta = rotateDelta90graus(delta)
            newarea[delta.y + cy][delta.x + cx] = value
        end
    end
    return newarea
end

function getAreaCenter(area)
    local x, y = getAreaWidthAndHeight(area)
    for tx = 1, x do
        for ty = 1, y do
            if area[ty][tx] == 2 or area[ty][tx] == 3 then
                return tx, ty
            end
        end
    end
end

function areaExists(area)
    if type(area) ~= "table" then
        return 0
    end
    if #area == 0 then
        return 0
    end
    for n = 1, #area do
        if type(area[n]) ~= "table" then
            return 0
        end
        if #area[n] == 0 then
            return 0
        end
        for n2 = 1, #area[n] do
            if type(area[n][n2]) ~= "number" then
                return 0
            end
        end
    end
    return 1
end

walls = {3491, 3485, 3491, 3485}

function isPisoNevado(itemid)
    if itemid == 670 or itemid == 671 or (itemid >= 6580 and itemid <= 6608) or (itemid >= 6613 and itemid <= 6626) or
        itemid == 6838 or (itemid >= 6683 and itemid <= 6686) or itemid == 7200 or itemid == 7236 then
        return 1
    else
        return 0
    end
end

function isPisoBordaDagua(itemid)
    if (itemid >= 4632 and itemid <= 4663) or itemid == 493 or (itemid >= 1360 and itemid <= 1363) or
        (itemid >= 4828 and itemid <= 4831) or (itemid >= 494 and itemid <= 505) or (itemid >= 6627 and itemid <= 6674) or
        (itemid >= 6687 and itemid <= 6694) then
        return 1
    else
        return 0
    end
end

function isPisoAgua(itemid)
    if (itemid >= 4608 and itemid <= 4625) or itemid == 493 or (itemid >= 4664 and itemid <= 4666) or
        (itemid >= 4820 and itemid <= 4825) then
        return 1
    else
        return 0
    end
end

function move(p)
    if isCreature(p.target) == 1 and isCreature(p.id) == 1 then
        doMoveCreature(p.target, getPushDir(p.id, p.target), 0)
    end
end

function move2(p)
    if isCreature(p.target) == 1 and isCreature(p.id) == 1 then
        doMoveCreature(p.target, getPlayerLookDir(p.id), 0)
    end
end

excluded_border = {921, 459, 922, 923, 925, 928, 931, 932, 934, 935, 938, 941, 942, 944, 945, 949, 950, 951, 952, 953,
                   954, 955, 959, 961, 962, 963, 4456, 4458, 4457, 4459, 4460, 442, 4461, 4462, 4463, 4464, 4465, 4466,
                   4467, 5045, 5047, 5049, 5048, 5050, 5051, 5052, 5053, 5054}
excluded_monster = {"Hit Box", "Kyogre", "Cerberus", "Sky Hydrodark"}
excluded_monster_chance = {
    ["Hit Box"] = 100,
    ["Kyogre"] = 50,
    ["Cerberus"] = 20,
    ["Sky Hydrodark"] = 35
}

function moveCreature(cid, target, dir)
    if not isCreature(target) or isNpc(target) or getPlayerGroupId(target) == 5 then
        return false
    end
    local player = Player(cid)
    local creature = Creature(target)
    if getPlayerStorageValue(target, storage.ingrainReduce) == 1 then
        return false
    end
    if creature:isPlayer() then
        if creature:getSkull() < 3 then
            if player:getHasSecured() == 1 then
                return false
            end
        end
    end

    if isInArray(excluded_monster, getCreatureName(target)) then
        if math.random(1, 100) <= excluded_monster_chance[getCreatureName(target)] then
            if getCreatureName(target) ~= "Hit Box" then
                doSendAnimatedText("Heavy!", getThingPos(target), TEXTCOLOR_AIR)
            end
            return false
        end
    end
    local tiara = getPlayerSlotItem(target, CONST_SLOT_HEAD)
    if tiara and tiara.itemid == 3971 then
        if math.random(1, 100) <= 50 then
            doSendMagicEffect(getThingPos(target), 30)
            return false
        end
    end
    local pos = getPositionByDirection(getThingPos(target), dir, 1)
    for i = 0, 255 do
        if isInArray(excluded_border, getThingfromPos({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            stackpos = i
        }).itemid) then
            return false
        end
        local nextPos = getPositionByDirection(getThingPos(target), dir, 1)
        if string.match(string.lower(getItemName(getThingfromPos({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            stackpos = i
        }).itemid)), ".*ramp.*") or string.match(string.lower(getItemName(getThingfromPos({
            x = nextPos.x,
            y = nextPos.y,
            z = nextPos.z,
            stackpos = i
        }).itemid)), ".*stairs.*") then
            return false
        end
    end

    if isWalkable(getPositionByDirection(getThingPos(target), dir, 1), true, true, true) then
        doMoveCreature(target, dir)
        -- else
        -- local newDir = player:getSimpleClosestFreePosition(dir, getPositionByDirection(getThingPos(target), dir, 1))

        -- if isWalkable(newDir, true, true, true) then
        --	creature:teleportTo(newDir, true)
        -- end
    end
end

function doDamageMoveCreature(cid, target, dir, type, minDmg, maxDmg, effect)
    if not isCreature(target) or not isCreature(cid) then
        return false
    end
    addEvent(moveCreature, 100, target, dir)
    if isWalkable(getCreatureLookPosition(target), true, true, true) then
        return doTargetCombatHealth(cid, target, type, minDmg, maxDmg, effect)
    else
        doTargetCombatHealth(cid, target, type, minDmg, maxDmg, effect)
        return true
    end
end

function createCombatObjects(n)
    local tabi = {}
    if n > 1 then
        for x = 1, n do
            table.insert(tabi, createCombatObject())
        end
    end
    return tabi
end

function exhaust(cid, storeValue, exhaustTime)
    exhaustMsg = "You are exhausted."
    newExhaust = os.time()
    oldExhaust = getPlayerStorageValue(cid, storeValue)
    if (oldExhaust == nil or oldExhaust < 0) then
        oldExhaust = 0
    end
    if (exhaustTime == nil or exhaustTime < 0) then
        exhaustTime = 5
    end
    diffTime = os.difftime(newExhaust, oldExhaust)
    if (diffTime >= exhaustTime) then
        setPlayerStorageValue(cid, storeValue, newExhaust)
        return 1
    else
        return 0
    end
end

function isPlayerOnPos(pos)
    local pos2 = pos
    pos2.stackpos = 253
    local thing = getThingfromPos(pos2)
    if (thing ~= nil and thing.itemid > 0) then
        if (isPlayer(thing.uid)) then
            return true
        end
    end
    return false
end

function comparePos(pos1, pos2)
    return (pos1.x == pos2.x and pos1.y == pos2.y and pos1.z == pos2.z)
end

function doPushCreature(uid, direction, distance, speed)
    -- Desenvolvido por Dokmos 30/01/2009
    -- Apoio Dinastias
    local pos = getThingPos(uid)
    local PARAM = {{1}, {500}}
    local DIRECTION = {{{0, 0}, {6, 7}, {1, 3}}, {{1, 1}, {5, 7}, {0, 2}}, {{2, 2}, {4, 5}, {1, 3}},
                       {{3, 3}, {4, 6}, {0, 2}}, {{4, 4}, {2, 3}}, {{5, 5}, {1, 2}}, {{6, 6}, {0, 1}}, {{7, 7}, {0, 3}}}
    table.insert(PARAM[1], distance)
    table.insert(PARAM[2], speed)

    for dvar = 1, #DIRECTION[direction + 1] do
        rand = math.random(2)
        d = DIRECTION[direction + 1][dvar][rand]
        dir = {
            x = (math.fmod(d, 2) * (-(d - 2)) + math.floor(d / 4) * math.fmod(d, 2) * d - math.floor(d / 4)),
            y = (((d - 1) * (d - 1 - (d - 1) * math.abs(d - 2)) * (1 - math.floor(d / 4))) -
                (math.floor(d / 4) * (math.floor(d / 6) * 2 - 1)))
        }
        newtile = {
            x = (pos.x + dir.x),
            y = (pos.y + dir.y),
            z = pos.z
        }
        if (getTileThingByPos(newtile).uid ~= 0) and (hasProperty(getTileThingByPos(newtile).uid, 3) == FALSE) and
            (queryTileAddThing(uid, newtile) == 1) then
            break
        end
        rand = (math.fmod(rand, 2) + 1)
        d = DIRECTION[direction + 1][dvar][rand]
        dir = {
            x = (math.fmod(d, 2) * (-(d - 2)) + math.floor(d / 4) * math.fmod(d, 2) * d - math.floor(d / 4)),
            y = (((d - 1) * (d - 1 - (d - 1) * math.abs(d - 2)) * (1 - math.floor(d / 4))) -
                (math.floor(d / 4) * (math.floor(d / 6) * 2 - 1)))
        }
        newtile = {
            x = (pos.x + dir.x),
            y = (pos.y + dir.y),
            z = pos.z
        }
        if (getTileThingByPos(newtile).uid ~= 0) and (hasProperty(getTileThingByPos(newtile).uid, 3) == FALSE) and
            (queryTileAddThing(uid, newtile) == 1) then
            break
        end
        if (dvar == #DIRECTION[direction + 1]) then
            newtile = pos
        end
    end

    doTeleportThing(uid, newtile, TRUE)
    if (PARAM[1][#PARAM[1]] > 1) then
        addEvent(doPushCreature, PARAM[2][#PARAM[2]], uid, direction, (distance - 1), speed)
    end
end

function getPosfromArea(cid, area, pos)
    icenter = math.floor(#area / 2) + 1
    jcenter = math.floor(#area[1] / 2) + 1
    center = area[icenter]
    ivar = #area
    jvar = #area[1]
    i = math.pow(#area, 2)
    j = math.pow(#area[1], 2)

    if center[jcenter] == 3 then
        if getPlayerLookDir(cid) == 0 then
            signal = {-1, 1, 1, 2}
        elseif getPlayerLookDir(cid) == 1 then
            signal = {1, -1, 2, 1}
        elseif getPlayerLookDir(cid) == 2 then
            signal = {1, -1, 1, 2}
        else
            signal = {-1, 1, 2, 1}
        end
    else
        signal = {-1, 1, 1, 2}
    end

    POSITIONS = {}
    P = 0

    repeat
        pvar = {0, 0}
        I = area[ivar]
        J = I[jvar]
        i = i - 1
        j = j - 1
        if J == 1 then
            if jvar < jcenter then
                pvar[signal[3]] = signal[1] * math.abs((jcenter - jvar))
            elseif jvar > jcenter then
                pvar[signal[3]] = signal[2] * math.abs((jcenter - jvar))
            end

            if ivar < icenter then
                pvar[signal[4]] = signal[1] * math.abs((icenter - ivar))
            elseif ivar > icenter then
                pvar[signal[4]] = signal[2] * math.abs((icenter - ivar))
            end
        end
        if jvar > 1 then
            jvar = (jvar - 1)
        elseif ivar > 1 then
            jvar = #area[1]
            ivar = (ivar - 1)
        end
        if not pos then
            pos = getThingPos(cid)
        end

        local areapos = {
            x = pos.x + (pvar[1]),
            y = pos.y + (pvar[2]),
            z = pos.z
        }
        if pos.x ~= areapos.x or pos.y ~= areapos.y then
            P = P + 1
            POSITIONS[P] = areapos
        end
    until i <= 0 and j <= 0

    return POSITIONS
end

function getDirectionBetween(fromPos, toPos, directions)
    dify = (fromPos.y - toPos.y)
    difx = (fromPos.x - toPos.x)
    local ARRAY = {}
    local BOOL = {0}

    local DIR = {{dify, -difx, -dify, difx},
                 {dify - math.abs(difx), -difx - math.abs(dify), -dify - math.abs(difx), difx - math.abs(dify),
                  difx - dify - math.abs(difx), -dify - math.abs(-difx) - difx, dify - math.abs(difx) + difx,
                  dify - math.abs(-difx) - difx}}

    table.insert(BOOL, directions)
    for d = 1, #DIR[BOOL[#BOOL] + 1] do
        table.insert(ARRAY, DIR[(BOOL[#BOOL]) + 1][d])
    end
    table.sort(ARRAY)

    return (table.find(DIR[BOOL[#BOOL] + 1], ARRAY[#ARRAY]) - 1)
end

function isWalkable(pos, creature, proj, pz) -- by Nord
    if getTileThingByPos({
        x = pos.x,
        y = pos.y,
        z = pos.z,
        stackpos = 0
    }).itemid == 0 then
        return false
    end
    if getTopCreature(pos).uid > 0 and creature then
        return false
    end
    if getTileInfo(pos).protection and pz then
        return false, true
    end
    local n = not proj and 3 or 2
    for i = 0, 255 do
        pos.stackpos = i
        local tile = getTileThingByPos(pos)
        if tile.itemid ~= 0 and not isCreature(tile.uid) then
            if hasProperty(tile.uid, n) or hasProperty(tile.uid, 7) then
                return false
            end
        end
    end
    return true
end

function createStones(pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    if (isWalkable(npos)) then
        doCreateItem(5747, 1, npos)
        addEvent(removeStones, time, 5747, npos)
    end
end

function createSpikes(pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    if (isWalkable(npos)) then
        doCreateItem(390, 1, npos)
        addEvent(removeStones, time, 390, npos)
    end
end

function valid(f)
    return function(p, ...)
        if isCreature(p) then
            return f(p, ...)
        end
    end
end

function createBarriers(pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    if (isWalkable(npos)) then
        doCreateItem(5619, 1, npos)
        addEvent(removeStones, time, 5619, npos)
    end
end

function createTile(pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    Game.createTile(npos, false)
    doCreateItem(460, 1, npos)
    addEvent(removeStones, time, 460, npos)
end

function createIngrainTree(pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    doCreateItem(5392, 1, npos)
    addEvent(removeIngrainTree, time * 1000, 5392, npos)
end

function removeIngrainTree(id, pos)
    for i = 0, 10 do
        pos.stackpos = i
        local item = getThingfromPos(pos)
        local x = item.itemid
        if x == id then
            doRemoveItem(item.uid, 1)
            return true
        end
    end
end

function createWalls(id, pos, time)
    local npos = {
        x = pos.x,
        y = pos.y,
        z = pos.z
    }
    doCreateItem(id, 1, npos)
    addEvent(removeStones, time, id, npos)
end

function removeStones(id, pos)
    for i = 0, 10 do
        pos.stackpos = i
        local item = getThingfromPos(pos)
        local x = item.itemid
        if x == id then
            doRemoveItem(item.uid, 1)
            return true
        end
    end
end

function moveCreatureLookDir(target, cid)
    if not isCreature(target) or not isCreature(cid) then
        return false
    end
    moveCreature(cid, target, getPlayerLookDir(cid))
end

function getCreatureLookPosition(cid)
    return getPositionByDirection(getThingPos(cid), getPlayerLookDir(cid))
end

function getPositionByDirection(position, direction, size) -- TFS FUNCTION
    local n = size or 1
    if (direction == NORTH) then
        position.y = position.y - n
    elseif (direction == SOUTH) then
        position.y = position.y + n
    elseif (direction == WEST) then
        position.x = position.x - n
    elseif (direction == EAST) then
        position.x = position.x + n
    elseif (direction == NORTHWEST) then
        position.y = position.y - n
        position.x = position.x - n
    elseif (direction == NORTHEAST) then
        position.y = position.y - n
        position.x = position.x + n
    elseif (direction == SOUTHWEST) then
        position.y = position.y + n
        position.x = position.x - n
    elseif (direction == SOUTHEAST) then
        position.y = position.y + n
        position.x = position.x + n
    end

    return position
end

function chargeDistanceEffect(cid, effect, indice, n)
    if not isCreature(cid) or n <= 0 then
        return false
    end

    if indice <= 0 then
        return true
    end
    local pos = getThingPos(cid)
    local area = {{
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }}
    local area2 = {{
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }}
    doSendDistanceShoot(area[(indice % #area)], area[(indice % #area) + 1], effect)
    doSendDistanceShoot(area2[(indice % #area2)], area2[(indice % #area) + 1], effect)
    addEvent(chargeDistanceEffect, 250, cid, effect, indice + 1, n - 1)
    return true
end

function chargeEffect(cid, effect, indice, n)
    if not isCreature(cid) or n <= 0 then
        return false
    end

    if indice == n then
        return true
    end
    local pos = getThingPos(cid)
    local area = {{
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }}
    local area2 = {{
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }, {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }, {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }}
    doSendMagicEffect(area[(indice % #area)], effect)
    doSendMagicEffect(area2[(indice % #area2)], effect)

    addEvent(chargeEffect, 170 - indice, cid, effect, indice + 1, n - 1)
    return true
end

function Player:canMove()
    if not self or not self:isPlayer() then
       return false
   end
   local cid = self:getId()
   local creature = Creature(cid)
   if creature:isMovementBlocked() then
       return false
   end
   return true
end

function noMove(cid, time, n)
    if not isCreature(cid) then
        return false
    end
    local player = Creature(cid)
    if n > 0 then
        player:setMovementBlocked(true)
        if n == 1 then
            player:setMovementBlocked(false)
        end
        addEvent(valid(noMove), time * 1000, cid, time, n - 1)
    else
        player:setMovementBlocked(false)
    end
    return true
end

function getCombatAreaPos(centerpos, area) -- by MaTTch
    if (type(area) ~= "table") then
        error("area is not a table")
        return false
    elseif (not centerpos) then
        return false
    end
    local t, center, ret = {}, {}, {}
    for n in ipairs(area) do
        for i = 2, 3 do
            if (table.find(area[n], i)) then
                center = {n, table.find(area[n], i)}
                break
            end
        end
    end
    if (#center == 0) then
        error("area do not have a number center")
        return false
    end
    for line in ipairs(area) do
        for _, value in ipairs(area[line]) do
            t[line] = t[line] and t[line] or {}
            if (value == 1 or value == 3) then
                table.insert(t[line], 1)
            else
                table.insert(t[line], 0)
            end
        end
    end
    for y in pairs(t) do
        for l, x in pairs(t[y]) do
            local ry, rx = y - center[1], l - center[2]
            if (#area == 1) then
                ry = 0
            end
            if (x == 1) then
                table.insert(ret, {
                    x = centerpos.x + (rx),
                    y = centerpos.y + (ry),
                    z = centerpos.z
                })
            end
        end
    end
    return ret
end

function haveTile(pos)
    return getTileThingByPos({
        x = pos.x,
        y = pos.y,
        z = pos.z,
        stackpos = 0
    }).itemid ~= 0
end

function create_wratharound(cid, pos)

    local playername = getCreatureName(cid)

    local npos = {
        x = pos.x + 1,
        y = pos.y + 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end

    local npos = {
        x = pos.x,
        y = pos.y + 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end

    local npos = {
        x = pos.x - 1,
        y = pos.y + 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end

    local npos = {
        x = pos.x + 1,
        y = pos.y,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end
    local npos = {
        x = pos.x - 1,
        y = pos.y,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end
    local npos = {
        x = pos.x + 1,
        y = pos.y - 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end
    local npos = {
        x = pos.x,
        y = pos.y - 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end
    local npos = {
        x = pos.x - 1,
        y = pos.y - 1,
        z = pos.z
    }
    if haveTile(npos) then
        if (isWalkable(npos)) then
            local item = doCreateItem(1397, 1, npos)
            if not item then
                return false
            end
            doDecayItem(item)
            doItemSetAttribute(item, "name", "a mystic flame. They belongs to " .. playername)
        end
    end
end

function doItemSetAttribute(uid, key, value)
    return Item(uid):setAttribute(key, value)
end

function doItemEraseAttribute(uid, key)
    return Item(uid):removeAttribute(key)
end

function getItemAttribute(uid, key)
    local i = ItemType(Item(uid):getId())
    local string_attributes = {
        [ITEM_ATTRIBUTE_NAME] = i:getName(),
        [ITEM_ATTRIBUTE_ARTICLE] = i:getArticle(),
        [ITEM_ATTRIBUTE_PLURALNAME] = i:getPluralName(),
        ["name"] = i:getName(),
        ["article"] = i:getArticle(),
        ["pluralname"] = i:getPluralName()
    }

    local numeric_attributes = {
        [ITEM_ATTRIBUTE_WEIGHT] = i:getWeight(),
        [ITEM_ATTRIBUTE_ATTACK] = i:getAttack(),
        [ITEM_ATTRIBUTE_DEFENSE] = i:getDefense(),
        [ITEM_ATTRIBUTE_EXTRADEFENSE] = i:getExtraDefense(),
        [ITEM_ATTRIBUTE_ARMOR] = i:getArmor(),
        [ITEM_ATTRIBUTE_HITCHANCE] = i:getHitChance(),
        [ITEM_ATTRIBUTE_SHOOTRANGE] = i:getShootRange(),
        ["weight"] = i:getWeight(),
        ["attack"] = i:getAttack(),
        ["defense"] = i:getDefense(),
        ["extradefense"] = i:getExtraDefense(),
        ["armor"] = i:getArmor(),
        ["hitchance"] = i:getHitChance(),
        ["shootrange"] = i:getShootRange()
    }

    local attr = Item(uid):getAttribute(key)
    if tonumber(attr) then
        if numeric_attributes[key] then
            return attr ~= 0 and attr or numeric_attributes[key]
        end
    else
        if string_attributes[key] then
            if attr == "" then
                return string_attributes[key]
            end
        end
    end
    return attr
end

function nearWater(cid)
    local area = {{1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 0, 0, 0, 1}, {1, 0, 2, 0, 1}, {1, 0, 0, 0, 1}, {1, 1, 1, 1, 1},
                  {1, 1, 1, 1, 1}}
    local mitem = nil
    local nearWaterPos = getPosfromArea(cid, area)
    for _, v in ipairs(nearWaterPos) do
        mitem = getTileThingByPos(v)

        if isPisoAgua(mitem.itemid) == 1 then
            return true
        end
    end
end

function nearPool(cid)
    local area = {{1, 1, 1}, {1, 2, 1}, {1, 1, 1}}
    local mitem = nil
    local nearWaterPos = getPosfromArea(cid, area)
    for _, v in ipairs(nearWaterPos) do

        for x = 1, 255 do
            if getThingfromPos({
                x = v.x,
                y = v.y,
                z = v.z,
                stackpos = x
            }).itemid == 2016 then
                doTransformItem(getThingfromPos({
                    x = v.x,
                    y = v.y,
                    z = v.z,
                    stackpos = x
                }).uid, getThingfromPos({
                    x = v.x,
                    y = v.y,
                    z = v.z,
                    stackpos = x
                }).itemid + 1, 1)
                return true
            end
        end
    end
end

function hasWater(cid, porcento)
    if nearWater(cid) then
        doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, "Using ambient water.")
        return true
    end
    
    if porcento > 100 then
        return true
    end

    for x = 0, 1 do
        if string.match(string.lower(getItemName(getThingfromPos({
            x = getThingPos(cid).x,
            y = getThingPos(cid).y,
            z = getThingPos(cid).z,
            stackpos = x
        }).itemid)), "ocean floor") then
            doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, "Using ambient water.")
            return true
        end
    end

    -- Função recursiva para procurar em containers
    local function findWaterPouch(container)
        if not container then return nil end
        
        for i = 0, container:getSize() - 1 do
            local item = container:getItem(i)
            if not item then
                break
            end
            
            -- Verifica se é um water pouch
            if item:getId() == 4864 then
                local actionId = item:getActionId()
                if (actionId == 0 and 100 or actionId - 100) >= porcento then
                    return item
                end
            end
            
            -- Se for um container, procura dentro dele
            if item:isContainer() then
                local foundItem = findWaterPouch(item)
                if foundItem then
                    return foundItem
                end
            end
        end
        return nil
    end

    local player = Player(cid)
    
    -- Procura em todos os slots do inventário (1-10 são os slots principais)
    for slot = 1, 10 do
        local item = player:getSlotItem(slot)
        if item then
            if item:getId() == 4864 then
                local actionId = item:getActionId()
                if (actionId == 0 and 100 or actionId - 100) >= porcento then
                    local newtype = (actionId == 0 and 200 or actionId) - porcento
                    if newtype == 100 then
                        item:transform(4863)
                    end
                    item:setActionId(newtype)
                    item:setAttribute("description", "Remaining: " .. (newtype - 100) .. "%")
                    doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, "Remaining: " .. (newtype - 100) .. "%")
                    return true
                end
            end
            
            -- Se for um container, procura dentro dele
            if item:isContainer() then
                local pouch = findWaterPouch(item)
                if pouch then
                    local actionId = pouch:getActionId()
                    local newtype = (actionId == 0 and 200 or actionId) - porcento
                    if newtype == 100 then
                        pouch:transform(4863)
                    end
                    pouch:setActionId(newtype)
                    pouch:setAttribute("description", "Remaining: " .. (newtype - 100) .. "%")
                    doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, "Remaining: " .. (newtype - 100) .. "%")
                    return true
                end
            end
        end
    end
    
    doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, "There is not enough water to perform this ability.")
    return false
end

function traceRoute(fromPos, toPos) -- Function by Notorious, edited by Socket
    local nextPos, route = fromPos, {}

    repeat
        if ((nextPos.x ~= toPos.x) and (nextPos.y ~= toPos.y)) then
            nextPos.x = nextPos.x + (toPos.x > nextPos.x and 1 or -1)

            table.insert(route, {
                x = nextPos.x,
                y = nextPos.y,
                z = nextPos.z
            })

            nextPos.y = nextPos.y + (toPos.y > nextPos.y and 1 or -1)

            table.insert(route, {
                x = nextPos.x,
                y = nextPos.y,
                z = nextPos.z
            })
        else
            if (nextPos.x ~= toPos.x) then
                nextPos.x = nextPos.x + (toPos.x > nextPos.x and 1 or -1)
            end

            if (nextPos.y ~= toPos.y) then
                nextPos.y = nextPos.y + (toPos.y > nextPos.y and 1 or -1)
            end

            table.insert(route, {
                x = nextPos.x,
                y = nextPos.y,
                z = nextPos.z
            })
        end
    until nextPos.x == toPos.x and nextPos.y == toPos.y
    return route
end

secundaryVocation = {
    [1] = "Knight",
    [2] = "Berserker",
    [3] = "Paladin"
}

function setPlayerSecundaryVocation(cid, voc)
    return setPlayerStorageValue(cid, storage.secundary_vocation, voc)
end

function getSecundaryVocation(cid)
    return getPlayerStorageValue(cid, storage.secundary_vocation) or 0
end

function getPlayerSecVocationName(cid)
    return secundaryVocation[getPlayerStorageValue(cid, storage.secundary_vocation)]
end

local function mapAreaGen(fromPos, toPos)
    for x = fromPos.x, toPos.x do
        for y = fromPos.y, toPos.y do
            for z = fromPos.z, toPos.z do
                coroutine.yield(Position(x, y, z))
            end
        end
    end
end

function mapArea(fromPos, toPos)
    local co = coroutine.create(function()
        mapAreaGen(fromPos, toPos)
    end)
    return function()
        local _, pos = coroutine.resume(co)
        return pos
    end
end

function setAvatar(cid)
    local player = Player(cid)
    local oldvoc = player:getVocation():getId()
    local playerGuid = player:getGuid()

    local old_avatar_id = getGlobalStorageData(storage.avatar_id)
    setGlobalStorageData(storage.avatar_id, old_avatar_id + 1, "number")
    local avatar_id = getGlobalStorageData(storage.avatar_id)
    print("Avatar Numero:" .. avatar_id)
    db.query("UPDATE `players` SET `avatar_id` = " .. avatar_id .. " WHERE `id` = " .. playerGuid .. ";")
    player:setVocation(5)
    player:setStorageValue(storage.avatar_time, os.time() + 23 * 60 * 60)
    player:setStorageValue(storage.old_vocation, oldvoc)
    player:save()
    saveGlobalStorages()
end

function eraseAvatar(cid)
    local player = Player(cid)
    if player:getStorageValue(storage.avatar_time) < os.time() and player:getStorageValue(storage.avatar_time) ~= -1 then
        local playerid = player:getGuid()
        local oldVocation = player:getStorageValue(storage.old_vocation)
        player:setStorageValue(storage.avatar_time, -1)
        player:setVocation(oldVocation)
        player:save()
        player:sendTextMessage(MESSAGE_EVENT_ADVANCE, "O seu avatar chegou ao fim.")
    else
        return false
    end
end

function isInverseDir(dir1, dir2)
    if (dir1 == 0 and dir2 == 2) or (dir1 == 2 and dir2 == 0) then
        return true
    elseif (dir1 == 1 and dir2 == 3) or (dir1 == 3 and dir2 == 1) then
        return true
    else
        return false
    end
    return false
end

function getStepSpeed(cid, pos) -- usado em boost, track, rocket, surf
    -- print("################")
    local tile_speed = 10
    local item = getThingfromPos({
        x = pos.x,
        y = pos.y,
        z = pos.z,
        stackpos = 0
    }) -- getTileThingByPos(pos)
    if item and item.uid > 0 then
        -- print("ITEM FOUND: " .. item.itemid)
        tile_speed = getItemInfo(item.itemid).speed
        tile_speed = math.min(150, tile_speed == 0 and 500 or tile_speed)
        print("TILE SPEED: " .. tile_speed)
    end

    return 1000 * tile_speed / math.max(getCreatureBaseSpeed(cid), getCreatureSpeed(cid))
end

function doLoadSpell(cid, pos, time, interval, effect)
    if time <= 0 then
        return true
    end
    for i = 1, 2 do
        local toPos = {
            x = pos.x + (math.random(-2, 2)),
            y = pos.y - (math.random(-2, 2)),
            z = pos.z
        }
        doSendDistanceShoot(toPos, getThingPos(cid), effect)
    end
    addEvent(doLoadSpell, interval, cid, pos, time - 1, interval, effect)
end

function doSendEssence(cid, time, essence, buff, pos)
    if time == 5 then
        if getTopCreature(pos).uid == cid then
            pos = {
                x = pos.x + math.random(-1, 1),
                y = pos.y - math.random(-1, 1),
                z = pos.z
            }
        else
            return true
        end
    end
    if time <= 0 then
        if getTopCreature(pos).uid > 0 and getTopCreature(pos).uid == cid then
            if essence == 'exp' then
                local exp = math.random(1, buff)
                doSendAnimatedText(exp, pos, TEXTCOLOR_WHITE_EXP)
                doPlayerSendTextMessage(cid, MESSAGE_EVENT_ADVANCE, "You got the essence of the monster exp: " .. exp)
                doPlayerAddExp(cid, exp)
            end
        end
        return true
    end
    doSendAnimatedText(essence, pos, TEXTCOLOR_YELLOW)
    doSendMagicEffect(pos, 29)
    addEvent(doSendEssence, 1000, cid, time - 1, essence, buff, pos)
end

function getSpeedStorage(cid)
    if (getPlayerStorageValue(cid, storage.speed) == -1) then
        setPlayerStorageValue(cid, storage.speed, 0)
    end
    return getPlayerStorageValue(cid, storage.speed)
end

function addSpeedStorage(cid, value)
    if (getPlayerStorageValue(cid, storage.speed) == -1) then
        setPlayerStorageValue(cid, storage.speed, 1)
    end
    return setPlayerStorageValue(cid, storage.speed, getSpeedStorage(cid) + value)
end

function getSkillPoints(cid)
    if (getPlayerStorageValue(cid, storage.skillpoints) == -1) then
        setPlayerStorageValue(cid, storage.skillpoints, 0)
    end
    return getPlayerStorageValue(cid, storage.skillpoints)
end

function addSkillPoints(cid, value)
    if (getPlayerStorageValue(cid, storage.skillpoints) == -1) then
        setPlayerStorageValue(cid, storage.skillpoints, 1)
    end
    return setPlayerStorageValue(cid, storage.skillpoints, getSkillPoints(cid) + value)
end

function removeSkillPoints(cid, value)
    return setPlayerStorageValue(cid, storage.skillpoints, getSkillPoints(cid) - value)
end

function doSendAnimatedText(text, pos, color)
    if type(text) == "number" then
        text = tostring(text)
    end
    
    local spectators = Game.getSpectators(Position(pos.x, pos.y, pos.z), false, true, 7, 7, 5, 5)
    if #spectators > 0 then
        for _, spectator in ipairs(spectators) do
            if spectator:isPlayer() then
                spectator:say(text, TALKTYPE_MONSTER_SAY, false, spectator, Position(pos.x, pos.y, pos.z))
            end
        end
    end
    return true
end

